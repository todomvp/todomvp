{"version":3,"sources":["index.esm.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["const ARRAYTYPE = '[object Array]'\nconst OBJECTTYPE = '[object Object]'\nconst FUNCTIONTYPE = '[object Function]'\nconst clone = require('rfdc')()\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function diffData(current, previous) {\n  const result = {}\n  if (!previous) return current\n  syncKeys(current, previous)\n  _diff(current, previous, '', result)\n  return result\n};exports.diffData = diffData\n\nfunction syncKeys(current, previous) {\n  if (current === previous) return\n  const rootCurrentType = getType(current)\n  const rootPreType = getType(previous)\n  if (rootCurrentType == OBJECTTYPE && rootPreType == OBJECTTYPE) {\n    for (let key in previous) {\n      const currentValue = current[key]\n      if (currentValue === undefined) {\n        current[key] = null\n      } else {\n        syncKeys(currentValue, previous[key])\n      }\n    }\n  } else if (rootCurrentType == ARRAYTYPE && rootPreType == ARRAYTYPE) {\n    if (current.length >= previous.length) {\n      previous.forEach((item, index) => {\n        syncKeys(current[index], item)\n      })\n    }\n  }\n}\n\nfunction _diff(current, previous, path, result) {\n  if (current === previous) return\n  const rootCurrentType = getType(current)\n  const rootPreType = getType(previous)\n  if (rootCurrentType == OBJECTTYPE) {\n    if (rootPreType != OBJECTTYPE || Object.keys(current).length < Object.keys(previous).length && path !== '') {\n      setResult(result, path, current)\n    } else {\n      for (let key in current) {\n        const currentValue = current[key]\n        const preValue = previous[key]\n        const currentType = getType(currentValue)\n        const preType = getType(preValue)\n        if (currentType != ARRAYTYPE && currentType != OBJECTTYPE) {\n          if (currentValue !== previous[key]) {\n            setResult(result, concatPathAndKey(path, key), currentValue)\n          }\n        } else if (currentType == ARRAYTYPE) {\n          if (preType != ARRAYTYPE) {\n            setResult(result, concatPathAndKey(path, key), currentValue)\n          } else {\n            if (currentValue.length < preValue.length) {\n              setResult(result, concatPathAndKey(path, key), currentValue)\n            } else {\n              currentValue.forEach((item, index) => {\n                _diff(item, preValue[index], concatPathAndKey(path, key) + '[' + index + ']', result)\n              })\n            }\n          }\n        } else if (currentType == OBJECTTYPE) {\n          if (preType != OBJECTTYPE || Object.keys(currentValue).length < Object.keys(preValue).length) {\n            setResult(result, concatPathAndKey(path, key), currentValue)\n          } else {\n            for (let subKey in currentValue) {\n              const realPath = concatPathAndKey(path, key) + (subKey.includes('.') ? `[\"${subKey}\"]` : `.${subKey}`)\n              _diff(currentValue[subKey], preValue[subKey], realPath, result)\n            }\n          }\n        }\n      }\n    }\n  } else if (rootCurrentType == ARRAYTYPE) {\n    if (rootPreType != ARRAYTYPE) {\n      setResult(result, path, current)\n    } else {\n      if (current.length < previous.length) {\n        setResult(result, path, current)\n      } else {\n        current.forEach((item, index) => {\n          _diff(item, previous[index], path + '[' + index + ']', result)\n        })\n      }\n    }\n  } else {\n    setResult(result, path, current)\n  }\n}\n\nfunction concatPathAndKey(path, key) {\n  return key.includes('.')\n    ? path + `[\"${key}\"]`\n    : (path == '' ? '' : path + \".\") + key\n}\n\nfunction setResult(result, k, v) {\n  if (getType(v) != FUNCTIONTYPE) {\n    result[k] = v\n  }\n}\n\nfunction getType(obj) {\n  return Object.prototype.toString.call(obj)\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function update(view, callback) {\n  const patch = diffData(view.data, view._westorePrevData)\n  view.setData(patch, callback)\n  view._westorePrevData = clone(view.data)\n};exports.update = update\n\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });class Store {\n  constructor() {\n    this.views = {}\n    this._westoreViewId = 0\n  }\n\n  bind(keyOrView, view) {\n    if (arguments.length === 1) {\n      this.data = keyOrView.data\n      this.views[this._westoreViewId++] = keyOrView\n    } else {\n      //设置回 view 的 data，不然引用地址 错误\n      this.data = view.data\n      this.views[keyOrView] = view\n    }\n  }\n\n  update(viewKey) {\n    if (arguments.length === 1) {\n      update(this.views[viewKey])\n    } else {\n      for (const key in this.views) {\n        update(this.views[key])\n      }\n    }\n  }\n};exports.Store = Store"]}